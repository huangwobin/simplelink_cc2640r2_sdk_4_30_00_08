

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Radio operation commands &mdash; 
SimpleLink™ CC2640R2 SDK
Proprietary RF User&#39;s Guide
 2.70.0 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="PHY Configuration" href="phy-configuration.html" />
    <link rel="prev" title="Command Types" href="commands.html" />
    <script language="JavaScript">
        var tiPageName;
        tiPageName = "sug rf-core radio-operation-commands";

        if (location.protocol == "file:"){
            var ci_analytics_poc_load = true;
        }
    </script>

    <script src="http://www.ti.com/assets/js/headerfooter/analytics.js" type="text/javascript" charset="utf-8"></script>


</head>

<body class="wy-body-for-nav">
   <!---- extra body elements for TI beyond RTD Sphinx Theme --->
<div class="DocSite-globalNav tiNav">
    <ul>
    </ul>
</div>

<a class="DocSite-nav" href="https://www.ti.com" style="padding-bottom: 85px;">
  <img class="DocSiteNav-logo"
    src="../_static/img/ti_logo.png"
    alt="TI Logo">
  <div class="DocSiteNav-title"></div>
</a> 
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../proprietary-rf-guide/index-cc2640.html" class="icon icon-home" alt="Documentation Home"> 
SimpleLink™ CC2640R2 SDK
Proprietary RF User's Guide

          

          
          </a>

          
            
            
              <div class="version">
                2.70.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/quickstart-cc2640.html">Proprietary RF Quick Start Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/index-platform-cc2640.html">The SimpleLink CC2640R2 SDK Platform</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/examples-cc2640.html">Examples User’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/custom-hardware.html">Custom hardware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/tirtos-index.html">TI-RTOS (RTOS Kernel) Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/nortos-index.html">noRTOS Overview</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../proprietary-rf-guide/rf-core-index.html">RF Core</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="commands.html">Command Types</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Radio operation commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#execution-states-and-status-codes">Execution States and Status Codes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#command-execution-states">Command Execution States</a></li>
<li class="toctree-l4"><a class="reference internal" href="#error-cases">Error Cases</a></li>
<li class="toctree-l4"><a class="reference internal" href="#error-callback">Error Callback</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#start-and-end-triggers">Start and end triggers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#absolute-triggers-trig-abstime">Absolute triggers <code class="docutils literal notranslate"><span class="pre">TRIG_ABSTIME</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#relative-triggers-trig-rel">Relative triggers <code class="docutils literal notranslate"><span class="pre">TRIG_REL_*</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#external-triggers-trig-external">External triggers <code class="docutils literal notranslate"><span class="pre">TRIG_EXTERNAL</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#alternative-triggers-via-cmd-trigger">Alternative triggers via CMD_TRIGGER</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#conditional-execution-and-chaining">Conditional execution and chaining</a></li>
<li class="toctree-l2"><a class="reference internal" href="#callback-events">Callback events</a></li>
<li class="toctree-l2"><a class="reference internal" href="phy-configuration.html">PHY Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="data-queues.html">Working with Data Queues</a></li>
<li class="toctree-l2"><a class="reference internal" href="signal-routing.html">Routing RF Core Signals to Physical Pins</a></li>
<li class="toctree-l2"><a class="reference internal" href="signal-routing.html#routing-internal-signals-to-the-doorbell-register">Routing Internal Signals to the Doorbell Register</a></li>
<li class="toctree-l2"><a class="reference internal" href="signal-routing.html#routing-doorbell-signals-to-gpio-pins">Routing Doorbell Signals to GPIO Pins</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/proprietary-rf-index-cc2640.html">Proprietary Physical Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/easylink-index.html">EasyLink Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/debugging-index.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/memory-index.html">Memory overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cc2640/oad-easylink/oad.html">Over the Air Download (OAD)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/migration-cc2640.html">Migration Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/reference-cc2640.html">API References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/glossary-cc2640.html">Terms and acronyms</a></li>
</ul>

            
          
          <!-- extra nav elements for TI beyond RTD Sphinx Theme --->
<div id="sideBanner">
    <br/>
    <br/><br/><br/>
</div>
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../proprietary-rf-guide/index-cc2640.html">
SimpleLink™ CC2640R2 SDK
Proprietary RF User's Guide
</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../proprietary-rf-guide/index-cc2640.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../proprietary-rf-guide/rf-core-index.html">RF Core</a> &raquo;</li>
        
      <li>Radio operation commands</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="radio-operation-commands">
<span id="sec-rf-radio-operation-commands"></span><h1>Radio operation commands<a class="headerlink" href="#radio-operation-commands" title="Permalink to this headline">¶</a></h1>
<p>Radio operation commands are more complex than direct and immediate commands
and their execution can take much longer time. In order to understand the
whole process, it may help to think of the RF core as a washing machine and
the radio operation commands as washing programs. The command parameters
represent all the knobs and buttons that modify the chosen program.</p>
<div class="section" id="execution-states-and-status-codes">
<span id="rf-core-execution-states-status-codes"></span><h2>Execution States and Status Codes<a class="headerlink" href="#execution-states-and-status-codes" title="Permalink to this headline">¶</a></h2>
<p>After delivering to the RF core, a radio operation passes several states. They
are illustrated as a UML state chart in <a class="reference internal" href="#fig-command-execution-states"><span class="std std-numref">Figure 37.</span></a>
and explained in <a class="reference internal" href="#tab-command-execution-states"><span class="std std-numref">Table 1.</span></a> Each state performs
several activities which are explained during the next sections.</p>
<div class="figure" id="id3">
<span id="fig-command-execution-states"></span><p class="plantuml">
<img src="../_images/plantuml-2458542d91c34566c4c58c22a6b7f7dfd828c346.png" alt=" &#64;startuml
 scale 0.8

 state PENDING {
     state Parsing
     state WaitingForStartTrigger
     [*] -&gt; Parsing
     Parsing --&gt; WaitingForStartTrigger : ok
     Parsing --&gt; [*] : failed
     Parsing --&gt; [*] : skipped
     WaitingForStartTrigger -&gt; [*] : triggered
 }
 state ACTIVE {
     state Executing
     note right
         command-specific
     end note
     state Evaluating : evaluate(result);
     note left
         might set skipping = true
         for chained commands
     end note

     [*] -&gt; Executing
     Executing --&gt; Evaluating : finished / result
     Evaluating -&gt; [*]

 }
 state DONE as &quot;DONE*&quot;
 state ERROR as &quot;ERROR*&quot;

 [*] -&gt; IDLE
 IDLE -&gt; PENDING : posted
 PENDING --&gt; ACTIVE : triggered
 PENDING -&gt; SKIPPED :  skipped
 PENDING --&gt; ERROR : parsing failed
 ACTIVE --&gt; DONE : done [success]
 ACTIVE --&gt; PENDING : done\n [skipping == true,\ncmd.condition.nSkip == 0]
 ACTIVE -&gt; ERROR : done [fail]
 DONE -[hidden]-&gt; ERROR
 DONE --&gt; [*]
 SKIPPED --&gt; [*]
 ERROR -&gt; [*]

 &#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 37. </span><span class="caption-text">The life-cycle of a radio operation. The state is equivalent
to the status code despite of states marked with a * .</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
<div class="section" id="command-execution-states">
<h3>Command Execution States<a class="headerlink" href="#command-execution-states" title="Permalink to this headline">¶</a></h3>
<span id="tab-command-execution-states"></span><table border="1" class="docutils" id="id4">
<caption><span class="caption-number">Table 1. </span><span class="caption-text">Command status codes as defined in <code class="docutils literal notranslate"><span class="pre">&lt;ti/devices/${DEVICE_FAMILY}/driverlib/rf_mailbox.h&gt;</span></code>.
       Status codes marked with a (*) do not exist, but represent
       multiple command-specific variants.</span><a class="headerlink" href="#id4" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="9%" />
<col width="91%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Status</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>IDLE</td>
<td>The command has not been posted to the RF core, yet. This is the default status.</td>
</tr>
<tr class="row-odd"><td>PENDING</td>
<td>The command is being parsed and the RF core waits for the start trigger to fire.</td>
</tr>
<tr class="row-even"><td>ACTIVE</td>
<td>This state is very command-specific. The command executes until it terminates.
Some commands provide also end triggers for alternative termination.
Command execution produces a result, either of <code class="docutils literal notranslate"><span class="pre">TRUE</span></code>, <code class="docutils literal notranslate"><span class="pre">FALSE</span></code> or <code class="docutils literal notranslate"><span class="pre">ABORT</span></code>.
After the execution phase, both, the result value and the command condition
rule get evaluated.
Several command-specific callback events may be generated during the <code class="docutils literal notranslate"><span class="pre">ACTIVE</span></code> state.</td>
</tr>
<tr class="row-odd"><td>DONE*</td>
<td>A command-specific status code is written to <code class="docutils literal notranslate"><span class="pre">status</span></code> and a callback event is generated
for single commands or for the last command in a chain.</td>
</tr>
<tr class="row-even"><td>ERROR*</td>
<td>Either parsing failed or command execution ended with an error. A command-specific error code is
written to <code class="docutils literal notranslate"><span class="pre">status</span></code> and a callback event is generated.</td>
</tr>
<tr class="row-odd"><td>SKIPPED</td>
<td>The command was skipped due to a skipping rule in a previous command.
<code class="docutils literal notranslate"><span class="pre">command.status</span></code> is set to <code class="docutils literal notranslate"><span class="pre">SKIPPED</span></code>. This applies only to commands in chains.
A callback is not performed.</td>
</tr>
</tbody>
</table>
<p>States marked with (*) do not exist as one explicit status code, but as
various command-specific variants. The code <code class="docutils literal notranslate"><span class="pre">PROP_DONE_OK</span></code>, for instance, is
specific to proprietary commands.</p>
<p>Status codes are defined in
<code class="docutils literal notranslate"><span class="pre">&lt;ti/devices/${DEVICE_FAMILY}/driverlib/rf_mailbox.h&gt;</span></code> for common radio
operations. Additional codes for proprietary commands are are defined in
<code class="docutils literal notranslate"><span class="pre">&lt;ti/devices/${DEVICE_FAMILY}/driverlib/rf_prop_mailbox.h&gt;</span></code>.</p>
<p>The status is queried via the command’s status field that is available for every
radio operation:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">RF_Op</span> <span class="p">{</span>
   <span class="c1">// ...</span>
   <span class="kt">uint16_t</span> <span class="n">status</span><span class="p">;</span> <span class="c1">// An integer telling the status of the command. This value is</span>
                    <span class="c1">// updated by the RF core during operation and may be read by the</span>
                    <span class="c1">// system CPU at any time.</span>
    <span class="c1">// ...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>It is recommended to read the status <strong>only after command completion</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Assuming that &#39;command&#39; points to a valid radio operation and</span>
<span class="c1">// execution has completed. Volatile is needed because &#39;status&#39;</span>
<span class="c1">// is written on another processor.</span>
<span class="k">volatile</span> <span class="n">RF_Op</span><span class="o">*</span> <span class="n">command</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(((</span><span class="k">volatile</span> <span class="n">RF_Op</span><span class="o">*</span><span class="p">)</span><span class="n">command</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">PROP_DONE_RXTIMEOUT</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It is tempting to use the status member to synchronize to command execution,
for instance, to wait until the command has actually started:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Dangerous, don&#39;t do this!</span>
<span class="k">while</span> <span class="p">(((</span><span class="k">volatile</span> <span class="n">RF_Op</span><span class="o">*</span><span class="p">)</span><span class="n">command</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">!=</span> <span class="n">ACTIVE</span><span class="p">)</span> <span class="p">{}</span>
</pre></div>
</div>
<p>However, this is strongly discouraged because the calling thread might get
interrupted while the command has already finished in the meantime. Hence, the
<code class="docutils literal notranslate"><span class="pre">ACTIVE</span></code> state is never seen and the <code class="docutils literal notranslate"><span class="pre">while</span></code> loop runs forever. Instead,
use RF driver events to synchronize to command execution, either via callbacks
or <span>RF_pendCmd</span>.</p>
</div>
<div class="section" id="error-cases">
<h3>Error Cases<a class="headerlink" href="#error-cases" title="Permalink to this headline">¶</a></h3>
<p>Whenever executing an RF operation, it is good practice to check the status
code and test for possible error cases. Depending on whether it is a proprietary
or a PHY-independent command, several various status codes apply. It is up to
the application to take appropriate measures.</p>
<p>The following code snippet is an example of how to execute a TX operation and
how to check the status:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;ti/devices/${DEVICE_FAMILY}/driverlib/rf_prop_mailbox.h&gt;</span><span class="cp"></span>

<span class="c1">// Execute the command</span>
<span class="n">RF_EventMask</span> <span class="n">terminationReason</span> <span class="o">=</span> <span class="n">RF_runCmd</span><span class="p">(</span><span class="n">rfHandle</span><span class="p">,</span> <span class="p">(</span><span class="n">RF_Op</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">RF_cmdPropTx</span><span class="p">,</span>
                                           <span class="n">RF_PriorityNormal</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span> <span class="n">terminationReason</span> <span class="o">&amp;</span> <span class="n">RF_EventCmdDone</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// A radio operation command in a chain finished</span>
<span class="p">}</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">terminationReason</span> <span class="o">&amp;</span> <span class="n">RF_EventLastCmdDone</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// A stand-alone radio operation command or the last radio</span>
    <span class="c1">// operation command in a chain finished.</span>
<span class="p">}</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">terminationReason</span> <span class="o">&amp;</span>  <span class="n">RF_EventCmdCancelled</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Command canceled before it was started; it can be caused</span>
    <span class="c1">// by RF_cancelCmd() or RF_flushCmd().</span>
<span class="p">}</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">terminationReason</span> <span class="o">&amp;</span> <span class="n">RF_EventCmdAborted</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Abrupt command termination caused by RF_cancelCmd() or</span>
    <span class="c1">// RF_flushCmd().</span>
<span class="p">}</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">terminationReason</span> <span class="o">&amp;</span> <span class="n">RF_EventCmdStopped</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Graceful command termination caused by RF_cancelCmd() or</span>
    <span class="c1">// RF_flushCmd().</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="c1">// Uncaught error event</span>
<span class="p">}</span>

<span class="kt">uint32_t</span> <span class="n">cmdStatus</span> <span class="o">=</span> <span class="p">((</span><span class="k">volatile</span> <span class="n">RF_Op</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">RF_cmdPropTx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
<span class="k">switch</span><span class="p">(</span><span class="n">cmdStatus</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">case</span> <span class="nl">PROP_DONE_OK</span><span class="p">:</span>
        <span class="c1">// Packet transmitted successfully</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">PROP_DONE_STOPPED</span><span class="p">:</span>
        <span class="c1">// Received CMD_STOP while transmitting packet and finished</span>
        <span class="c1">// transmitting packet</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">PROP_DONE_ABORT</span><span class="p">:</span>
        <span class="c1">// Received CMD_ABORT while transmitting packet</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">PROP_ERROR_PAR</span><span class="p">:</span>
        <span class="c1">// Observed illegal parameter in the posted RF command</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">PROP_ERROR_NO_SETUP</span><span class="p">:</span>
        <span class="c1">// Command sent without setting up the radio in a supported</span>
        <span class="c1">// mode using CMD_PROP_RADIO_SETUP or CMD_RADIO_SETUP</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">PROP_ERROR_NO_FS</span><span class="p">:</span>
        <span class="c1">// Error case. Due to CMD_FS failing during power-up, CMD_PROP_TX</span>
        <span class="c1">// could not succeed. The RF core is powered up and the synth is not running.</span>
        <span class="c1">// One possible work-around is: Ignore it and power the RF core down</span>
        <span class="c1">// manually. CMD_FS will be re-executed on the next RF core power-up.</span>
        <span class="n">RF_yield</span><span class="p">(</span><span class="n">rfHandle</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">PROP_ERROR_TXUNF</span><span class="p">:</span>
        <span class="c1">// TX underflow observed during operation</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="c1">// Uncaught error event - these could come from the</span>
        <span class="c1">// pool of states defined in rf_mailbox.h</span>
        <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="error-callback">
<h3>Error Callback<a class="headerlink" href="#error-callback" title="Permalink to this headline">¶</a></h3>
<p>With the <span>RF_Params</span> struct, you can add an error callback:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">rfErrCb</span><span class="p">(</span><span class="n">RF_Handle</span> <span class="n">rfHandle</span><span class="p">,</span> <span class="n">RF_CmdHandle</span> <span class="n">rfCommandHandle</span><span class="p">,</span> <span class="n">RF_EventMask</span> <span class="n">rfEventMask</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span><span class="nf">mainThread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">RF_Params</span> <span class="n">rfParams</span><span class="p">;</span>
    <span class="n">RF_Params_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfParams</span><span class="p">);</span>
    <span class="n">rfParams</span><span class="p">.</span><span class="n">pErrCb</span> <span class="o">=</span> <span class="n">rfErrCb</span><span class="p">;</span>
</pre></div>
</div>
<p>In the following example, a <span>RF_ERROR_CMDFS_SYNTH_PROG</span> (synth
error) will be handled by posting a new <code class="docutils literal notranslate"><span class="pre">CMD_FS</span></code>. When you do
<span>RF_postCmd</span> in the error callback, the command will be appended
to the RF driver’s command queue. There is no possibility to inject another
<code class="docutils literal notranslate"><span class="pre">CMD_FS</span></code> before any command pending in the queue. When the error callback is
executed, the RF core just came from power-down and there is (usually) an RX or
TX command waiting in the RF driver queue. Thus, if we want the <code class="docutils literal notranslate"><span class="pre">CMD_FS</span></code> to be
the next command executed, we should cancel any RF command in the queue.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">rfErrCb</span><span class="p">(</span><span class="n">RF_Handle</span> <span class="n">rfHandle</span><span class="p">,</span> <span class="n">RF_CmdHandle</span> <span class="n">rfCommandHandle</span><span class="p">,</span> <span class="n">RF_EventMask</span> <span class="n">rfEventMask</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">rfCommandHandle</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="nl">RF_ERROR_INVALID_RFMODE</span><span class="p">:</span>
        <span class="c1">// Invalid RF_Mode.</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">RF_ERROR_CMDFS_SYNTH_PROG</span><span class="p">:</span>
    <span class="p">{</span>
        <span class="c1">// Synthesizer error with CMD_FS.</span>

        <span class="c1">// Cancel any RF commands in the queue</span>
        <span class="kt">uint8_t</span> <span class="n">stopMode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//1: Stop gracefully, 0: abort abruptly</span>
        <span class="n">RF_cancelCmd</span><span class="p">(</span><span class="n">rfHandle</span><span class="p">,</span> <span class="n">RF_CMDHANDLE_FLUSH_ALL</span><span class="p">,</span> <span class="n">stopMode</span><span class="p">);</span>
        <span class="c1">// Post a new CMD_FS</span>
        <span class="n">RF_postCmd</span><span class="p">(</span><span class="n">rfHandle</span><span class="p">,</span> <span class="p">(</span><span class="n">RF_Op</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">RF_cmdFs</span><span class="p">,</span> <span class="n">RF_PriorityNormal</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="c1">// Uncaught error handle</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p class="last">You must not use any blocking RF driver calls (such as
<span>RF_runCmd</span> and <span>RF_pendCmd</span>) in the error
callback! Instead, use non-blocking RF driver calls such as
<span>RF_postCmd</span>.</p>
</div>
</div>
</div>
</div>
<div class="section" id="start-and-end-triggers">
<span id="sec-rf-command-triggers"></span><h1>Start and end triggers<a class="headerlink" href="#start-and-end-triggers" title="Permalink to this headline">¶</a></h1>
<p>All radio operations provide a start trigger. It brings the command from
PENDING state into ACTIVE state and starts the actual command execution.</p>
<span id="tab-rf-command-triggers"></span><table border="1" class="docutils" id="id5">
<caption><span class="caption-number">Table 2. </span><span class="caption-text">Available trigger types. The identifiers can be found in
       <code class="docutils literal notranslate"><span class="pre">&lt;ti/devices/${DEVICE_FAMILY}/driverlib/rf_mailbox.h&gt;</span></code>.
       Identifiers marked with a (*) are only available for chained commands.</span><a class="headerlink" href="#id5" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="4%" />
<col width="15%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Number</th>
<th class="head">Identifier</th>
<th class="head">Trigger fires</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>TRIG_NOW</td>
<td>Immediately. Available for start triggers only. This is the default value.</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>TRIG_NEVER</td>
<td>Never, except possibly by CMD_TRIGGER if <code class="docutils literal notranslate"><span class="pre">bEnaCmd</span> <span class="pre">==</span> <span class="pre">1</span></code>. Default value for end triggers.</td>
</tr>
<tr class="row-even"><td>2</td>
<td>TRIG_ABSTIME</td>
<td>At an absolute time, specified by startTime.</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>TRIG_REL_SUBMIT</td>
<td>At a time relative to the command submission time.</td>
</tr>
<tr class="row-even"><td>4</td>
<td>TRIG_REL_START</td>
<td>At a time relative to the start of the command (when the start trigger fires). Available for end triggers only.</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>TRIG_REL_PREVSTART*</td>
<td>At a time relative to the start of the previous command. Applies only to chained commands.</td>
</tr>
<tr class="row-even"><td>6</td>
<td>TRIG_REL_FIRSTSTART*</td>
<td>At a time relative to the start of the first command in a chain.</td>
</tr>
<tr class="row-odd"><td>7</td>
<td>TRIG_REL_PREVEND*</td>
<td>At a time relative to the end of the previous command in a chain.</td>
</tr>
<tr class="row-even"><td>8</td>
<td>TRIG_REL_EVT1*</td>
<td>At a time relative to event 1 of the previous command in a chain.</td>
</tr>
<tr class="row-odd"><td>9</td>
<td>TRIG_REL_EVT2*</td>
<td>At a time relative to event 2 of the previous command in a chain.</td>
</tr>
<tr class="row-even"><td>10</td>
<td>TRIG_EXTERNAL</td>
<td>On an external trigger input.</td>
</tr>
</tbody>
</table>
<p>The start trigger configuration is defined by the following command members:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">RF_Op</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="n">ratmr_t</span> <span class="n">startTime</span><span class="p">;</span>                  <span class="c1">// Absolute or relative start time (depending on triggerType)</span>
    <span class="k">struct</span> <span class="p">{</span>
        <span class="kt">uint8_t</span> <span class="nl">triggerType</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span>          <span class="c1">// The type of trigger</span>
        <span class="kt">uint8_t</span> <span class="nl">bEnaCmd</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>              <span class="c1">// 1: CMD_TRIGGER can be used as an alternative trigger</span>
                                        <span class="c1">// 0: No alternative trigger command</span>
        <span class="kt">uint8_t</span> <span class="nl">triggerNo</span><span class="p">:</span><span class="mi">2</span><span class="p">;</span>            <span class="c1">// Specifies the trigger number when using CMD_TRIGGER (bEnaCmd is 1)</span>
                                        <span class="c1">// Valid values are 0..3.</span>
        <span class="kt">uint8_t</span> <span class="nl">pastTrig</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>             <span class="c1">// 1: A trigger event in the past is interpreted as &quot;fire now&quot;</span>
                                        <span class="c1">// 0: A trigger event in the past results in an error</span>
    <span class="p">}</span> <span class="n">startTrigger</span><span class="p">;</span>                     <span class="c1">// Trigger that starts the radio operation command</span>
    <span class="c1">// ...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>End triggers are only available for operations that run for a longer time and
wait for something to happen. CMD_PROP_RX is such a command. The
configuration of end triggers is very similar to start triggers:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">RF_Op</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="n">ratmr_t</span> <span class="n">endTime</span><span class="p">;</span>                    <span class="c1">// Absolute or relative end time (depending on triggerType)</span>
    <span class="k">struct</span> <span class="p">{</span>
        <span class="kt">uint8_t</span> <span class="nl">triggerType</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span>          <span class="c1">// The type of trigger</span>
        <span class="kt">uint8_t</span> <span class="nl">bEnaCmd</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>              <span class="c1">// 1: CMD_TRIGGER can be used as an alternative trigger</span>
                                        <span class="c1">// 0: No alternative trigger command</span>
        <span class="kt">uint8_t</span> <span class="nl">triggerNo</span><span class="p">:</span><span class="mi">2</span><span class="p">;</span>            <span class="c1">// Specifies the trigger number when using CMD_TRIGGER (bEnaCmd is 1)</span>
                                        <span class="c1">// Valid values are 0..3.</span>
        <span class="kt">uint8_t</span> <span class="nl">pastTrig</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>             <span class="c1">// 1: A trigger event in the past is interpreted as &quot;fire now&quot;</span>
                                        <span class="c1">// 0: A trigger event in the past results in an error</span>
    <span class="p">}</span> <span class="n">endTrigger</span><span class="p">;</span>                       <span class="c1">// Trigger that ends the radio operation command</span>
    <span class="c1">// ...</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="section" id="absolute-triggers-trig-abstime">
<span id="sec-trigger-abstime"></span><h2>Absolute triggers <code class="docutils literal notranslate"><span class="pre">TRIG_ABSTIME</span></code><a class="headerlink" href="#absolute-triggers-trig-abstime" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">TRIG_ABSTIME</span></code> fires at an absolute time stamp specified by the
<code class="docutils literal notranslate"><span class="pre">startTime</span></code> parameter. Absolute triggers are needed, for instance, when
implementing synchronous protocols where multiple commands must execute
relative to one common time base. This avoids glitches that one would observe
when using <code class="docutils literal notranslate"><span class="pre">TRIG_NOW</span></code> and timers on the main CPU.</p>
<p>Usually, <span>RF_getCurrentTime</span> is used to get the initial time
and all other times are set relative to that one. In the following code
snippet, a radio operation executes exactly every second:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define RF_convertMsToRatTicks(milliseconds) \</span>
<span class="cp">    ((uint32_t)(milliseconds) * 4 * 1000)</span>

<span class="n">command</span><span class="p">.</span><span class="n">startTrigger</span><span class="p">.</span><span class="n">triggerType</span> <span class="o">=</span> <span class="n">TRIG_ABSTIME</span><span class="p">;</span>
<span class="n">command</span><span class="p">.</span><span class="n">startTime</span> <span class="o">=</span> <span class="n">RF_getCurrentTime</span><span class="p">();</span>

<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">command</span><span class="p">.</span><span class="n">startTime</span> <span class="o">+=</span> <span class="n">RF_convertMsToRatTicks</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
    <span class="n">RF_runCmd</span><span class="p">(</span><span class="n">rfHandle</span><span class="p">,</span> <span class="p">(</span><span class="n">RF_Op</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">command</span><span class="p">,</span> <span class="n">RF_PriorityNormal</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">startTime</span></code> is not a future time stamp, then the trigger will never fire.
In such cases, <code class="docutils literal notranslate"><span class="pre">command.startTrigger.pastTrig</span></code> must be set to 1.</p>
<p>Please note, that the RF driver powers the RF core down while waiting for an
absolute start trigger. This trick is described in the RF driver API documentation.</p>
</div>
<div class="section" id="relative-triggers-trig-rel">
<h2>Relative triggers <code class="docutils literal notranslate"><span class="pre">TRIG_REL_*</span></code><a class="headerlink" href="#relative-triggers-trig-rel" title="Permalink to this headline">¶</a></h2>
<p>Relative triggers specify a time duration with respect to another event, for
instance relative to the start of a radio operation.
<a class="reference internal" href="#tab-rf-command-triggers"><span class="std std-numref">Table 2.</span></a> lists all available trigger types.</p>
<p>The duration is always specified in <a class="reference internal" href="../proprietary-rf-guide/glossary-cc2640.html#term-rat"><span class="xref std std-term">RAT</span></a> ticks.  The following code
snippet sets a relative end trigger for <a class="reference internal" href="rf-commands-reference/cmd_prop_cs.html"><span class="doc">CMD_PROP_CS</span></a>.  A helper macro
simplifies conversion.:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Convert microseconds into RAT ticks.</span>
<span class="cp">#define RF_convertUsToRatTicks(microseconds) \</span>
<span class="cp">    ((uint32_t)(microseconds) * 4)</span>

<span class="c1">// Convert milliseconds into RAT ticks.</span>
<span class="cp">#define RF_convertMsToRatTicks(milliseconds) \</span>
<span class="cp">    RF_convertUsToRatTicks((milliseconds) * 1000)</span>

<span class="c1">// Set a relative end trigger 4ms after execution start.</span>
<span class="n">RF_cmdPropCs</span><span class="p">.</span><span class="n">csEndTrigger</span><span class="p">.</span><span class="n">triggerType</span> <span class="o">=</span> <span class="n">TRIG_REL_START</span><span class="p">;</span>
<span class="n">RF_cmdPropCs</span><span class="p">.</span><span class="n">csEndTime</span> <span class="o">=</span> <span class="n">RF_converMsToRatTicks</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="external-triggers-trig-external">
<span id="trig-external"></span><h2>External triggers <code class="docutils literal notranslate"><span class="pre">TRIG_EXTERNAL</span></code><a class="headerlink" href="#external-triggers-trig-external" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">TRIG_EXTERNAL</span></code> is used to start and stop a radio operation by an external
hardware event. The event source is one of the internal RF core signals
<code class="docutils literal notranslate"><span class="pre">RFC_GPI0</span></code> or <code class="docutils literal notranslate"><span class="pre">RFC_GPI1</span></code>. These signals can be routed to a physical pin
using the IO controller.  Possible event types are either a rising edge, a
falling edge or both. Both, event source and type are encoded in the
<code class="docutils literal notranslate"><span class="pre">startTime</span></code> parameter of the radio operation.</p>
<p>The following code snippet shows how to start a command by a falling edge on
the GPIO pin <code class="docutils literal notranslate"><span class="pre">IOID_25</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Define a struct for convenience.</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="nl">reserved</span><span class="p">:</span><span class="mi">2</span><span class="p">;</span>  <span class="c1">// unused</span>
    <span class="kt">uint32_t</span> <span class="nl">inputMode</span><span class="p">:</span><span class="mi">2</span><span class="p">;</span> <span class="c1">// 0: rising, 1: falling, 2: both edges</span>
    <span class="kt">uint32_t</span> <span class="nl">reserved2</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span> <span class="c1">// unused</span>
    <span class="kt">uint32_t</span> <span class="nl">source</span><span class="p">:</span><span class="mi">5</span><span class="p">;</span>    <span class="c1">// 22: RFC_GPI0, 23: RFC_GPI1</span>
<span class="p">}</span> <span class="n">ExternalTrigger</span><span class="p">;</span>

<span class="c1">// Set the trigger configuration</span>
<span class="n">ExternalTrigger</span> <span class="n">triggerConfig</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">.</span><span class="n">inputMode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>       <span class="c1">// falling edge</span>
    <span class="p">.</span><span class="n">source</span> <span class="o">=</span> <span class="mi">22</span>          <span class="c1">// Use RFC_GPI0</span>
<span class="p">};</span>

<span class="n">command</span><span class="p">.</span><span class="n">startTrigger</span><span class="p">.</span><span class="n">triggerType</span> <span class="o">=</span> <span class="n">TRIG_EXTERNAL</span><span class="p">;</span>
<span class="n">command</span><span class="p">.</span><span class="n">startTime</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">triggerConfig</span><span class="p">);</span>

<span class="c1">// Route a physical pin to the internal RFC_GPI0 signal.</span>
<span class="n">PINCC26XX_setMux</span><span class="p">(</span><span class="n">buttonPinHandle</span><span class="p">,</span> <span class="n">IOID_25</span><span class="p">,</span> <span class="n">PINCC26XX_MUX_RFC_GPI0</span><span class="p">);</span>
</pre></div>
</div>
<p>See the section <a class="reference internal" href="signal-routing.html#rf-signal-routing"><span class="std std-ref">Routing RF Core Signals to Physical Pins</span></a> for more details on signal rounting.</p>
</div>
<div class="section" id="alternative-triggers-via-cmd-trigger">
<h2>Alternative triggers via CMD_TRIGGER<a class="headerlink" href="#alternative-triggers-via-cmd-trigger" title="Permalink to this headline">¶</a></h2>
<p>Sometimes it is desirable to trigger a radio operation based on a software
event. This can be achieved using the immediate command CMD_TRIGGER. Each
radio operation trigger provides the fields <code class="docutils literal notranslate"><span class="pre">bEnaCmd</span></code> and <code class="docutils literal notranslate"><span class="pre">triggerNo</span></code> to
do that. This trigger serves as an alternative trigger source. The original
trigger specified by <code class="docutils literal notranslate"><span class="pre">triggerType</span></code> is not affected. This means, that both,
timeout triggers and CMD_TRIGGER can be used at the same time.</p>
<p>The following code snippet shows how to set up a custom end trigger for a
infinitely running radio operation:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Set up the radio operation</span>
<span class="n">radioOp</span><span class="p">.</span><span class="n">endTrigger</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">TRIG_NEVER</span><span class="p">;</span> <span class="c1">// Run the command without a timeout</span>
                                      <span class="c1">// trigger.</span>
<span class="n">radioOp</span><span class="p">.</span><span class="n">endTrigger</span><span class="p">.</span><span class="n">bEnaCmd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>       <span class="c1">// Enable CMD_TRIGGER as an end trigger.</span>
<span class="n">radioOp</span><span class="p">.</span><span class="n">endTrigger</span><span class="p">.</span><span class="n">triggerNo</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>     <span class="c1">// Chose a value between 0 and 3.</span>

<span class="c1">// Set up the immediate trigger command</span>
<span class="n">rfc_CMD_TRIGGER</span> <span class="n">triggerCmd</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">commandNo</span> <span class="o">=</span> <span class="n">CMD_TRIGGER</span><span class="p">,</span>
    <span class="p">.</span><span class="n">triggerNo</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>                   <span class="c1">// Chose the same value as for the</span>
                                      <span class="c1">// radio operation command trigger</span>
                                      <span class="c1">// above.</span>
<span class="p">};</span>

<span class="c1">// Start the long-running radio operation</span>
<span class="n">RF_CmdHandle</span> <span class="n">radioOpHandle</span> <span class="o">=</span> <span class="n">RF_postCmd</span><span class="p">(</span><span class="n">rfHandle</span><span class="p">,</span> <span class="p">(</span><span class="n">RF_Op</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">radioOp</span><span class="p">,</span> <span class="n">RF_PriorityNormal</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="c1">// Do some work ...</span>

<span class="c1">// Finish execution of the radio operation by the trigger command</span>
<span class="n">RF_runImmediateCmd</span><span class="p">(</span><span class="n">rfHandle</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">triggerCmd</span><span class="p">);</span>
</pre></div>
</div>
<p>Another use case is the combination of alternative triggers with command
chaining. Let us assume that an application wants to achieve a fast transition
from CMD_PROP_RX to CMD_PROP_TX, but the exact time when this should
happen is unknown in advance. In this case, chaining CMD_PROP_RX with
CMD_PROP_TX and using CMD_TRIGGER to end the RX command is faster than
aborthing the RX command before posting the TX command.</p>
</div>
</div>
<div class="section" id="conditional-execution-and-chaining">
<span id="condition-evaluation"></span><h1>Conditional execution and chaining<a class="headerlink" href="#conditional-execution-and-chaining" title="Permalink to this headline">¶</a></h1>
<p>Multiple radio operations can be chained and the chains are executed according
to a result from the execution phase. The parameters are specified as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">RF_Op</span> <span class="p">{</span>
    <span class="c1">// ...</span>
   <span class="n">RF_Op</span><span class="o">*</span> <span class="n">pNextOp</span><span class="p">;</span>          <span class="c1">// Pointer to the next chained operation to run.</span>
   <span class="k">struct</span> <span class="p">{</span>
      <span class="kt">uint8_t</span> <span class="nl">rule</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span>       <span class="c1">// Condition for running next command: Rule for how to proceed.</span>
      <span class="kt">uint8_t</span> <span class="nl">nSkip</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span>      <span class="c1">// Parameter for skipping mode if the rule involves skipping.</span>
                            <span class="c1">// 0: repeat same command, 1: go to next, 2: skip next, ...</span>
   <span class="p">}</span> <span class="n">condition</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The execution phase of a radio operation always ends with a result that can be
either <code class="docutils literal notranslate"><span class="pre">TRUE</span></code>, <code class="docutils literal notranslate"><span class="pre">FALSE</span></code> or <code class="docutils literal notranslate"><span class="pre">ABORT</span></code> and is specific for every operation.
This result is evaluated together with <code class="docutils literal notranslate"><span class="pre">condition.rule</span></code> of the radio
operation. All available rules are listet in
<a class="reference internal" href="#tab-command-condition-rules"><span class="std std-numref">Table 3.</span></a>.</p>
<span id="tab-command-condition-rules"></span><table border="1" class="docutils" id="id6">
<caption><span class="caption-number">Table 3. </span><span class="caption-text">Available condition rules. The identifiers can be found in
       <code class="docutils literal notranslate"><span class="pre">&lt;ti/devices/${DEVICE_FAMILY}/driverlib/rf_mailbox.h&gt;</span></code>.
       Identifiers marked with a (*) are only available for chained commands.</span><a class="headerlink" href="#id6" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="5%" />
<col width="15%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Number</th>
<th class="head">Identifier</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>COND_ALWAYS</td>
<td>Always run next command (except in case of Abort).</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>COND_NEVER</td>
<td>Never run next command.</td>
</tr>
<tr class="row-even"><td>2</td>
<td>COND_STOP_ON_FALSE</td>
<td>Proceed with next command if this command finishes with result <code class="docutils literal notranslate"><span class="pre">TRUE</span></code>. Stop execution if <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>.</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>COND_STOP_ON_TRUE</td>
<td>Proceed with next command if this command finishes with result <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>. Stop execution if <code class="docutils literal notranslate"><span class="pre">TRUE</span></code>.</td>
</tr>
<tr class="row-even"><td>4</td>
<td>COND_SKIP_ON_FALSE</td>
<td>Proceed with next command if this command finishes with result <code class="docutils literal notranslate"><span class="pre">TRUE</span></code>. Go to skipping mode if <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>.</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>COND_SKIP_ON_TRUE</td>
<td>Go to skipping mode if this command finishes with result <code class="docutils literal notranslate"><span class="pre">TRUE</span></code>. Proceed with next command if <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>.</td>
</tr>
</tbody>
</table>
<p>Based on the evaluation outcome, another command may be started which is
specified by <code class="docutils literal notranslate"><span class="pre">pNextOp</span></code> and <code class="docutils literal notranslate"><span class="pre">condition.nSkip</span></code>. The latter parameter allows
for instance, to re-run the command when set to 0 or to go to the next command
when set to 1. It is even possible to jump to a command further in the chain
when greater than 1. In this case, the status of the skipped operation is set
to <code class="docutils literal notranslate"><span class="pre">SKIPPED</span></code>.</p>
<div class="figure align-center" id="id7">
<span id="fig-command-evaluating-phase"></span><p class="plantuml">
<img src="../_images/plantuml-4dcce038b26a293b68d55cfc327253d2a44f7a90.png" alt="&#64;startuml
scale 0.8
:Evaluating entry;
if (result) then (TRUE/FALSE)
    :next := evaluate(command, result)]
    if (next) then (is set)
         :start(next)]
    else (NULL)
        :RF_EventLastCmdDone&gt;
    endif
else (ABORT)
    :RF_EventLastCmdDone&gt;
endif
:RF_EventCmdDone&gt;
:Evaluating exit;
&#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 38. </span><span class="caption-text">SDL diagram of the Evaluating phase that was shown in
<a class="reference internal" href="#fig-command-execution-states"><span class="std std-numref">Figure 37.</span></a>.</span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></p>
</div>
<p>The generic part of the evaluating phase is illustrated in
<a class="reference internal" href="#fig-command-evaluating-phase"><span class="std std-numref">Figure 38.</span></a>. The pseudo function
<code class="docutils literal notranslate"><span class="pre">evaluate(command,</span> <span class="pre">result)</span></code> depends on the condition rule and skip count and
returns a pointer to the next radio operation. It is specified in
<a class="reference internal" href="#lst-rf-command-evaluate"><span class="std std-numref">Listing 17.</span></a> below. The <code class="docutils literal notranslate"><span class="pre">start(next)</span></code> pseudo function
just brings the next operation into the state <code class="docutils literal notranslate"><span class="pre">PENDING</span></code>.</p>
<div class="literal-block-wrapper docutils container" id="lst-rf-command-evaluate">
<div class="code-block-caption"><span class="caption-number">Listing 17. </span><span class="caption-text">Pseudo code for the <cite>evaluate()</cite> function from <a class="reference internal" href="#fig-command-evaluating-phase"><span class="std std-numref">Figure 38.</span></a>.</span><a class="headerlink" href="#lst-rf-command-evaluate" title="Permalink to this code">¶</a></div>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">RF_Op</span><span class="o">*</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">RF_OP</span><span class="o">*</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">result</span><span class="p">)</span>
    <span class="n">RF_Op</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span>

    <span class="n">select</span> <span class="p">(</span><span class="n">cmd</span><span class="p">.</span><span class="n">condition</span><span class="p">.</span><span class="n">rule</span><span class="p">)</span>
        <span class="k">case</span> <span class="n">COND_ALWAYS</span>
            <span class="n">next</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">.</span><span class="n">pNextOp</span>

        <span class="k">case</span> <span class="n">COND_NEVER</span>
            <span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span>

        <span class="k">case</span> <span class="n">COND_STOP_ON_FALSE</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>
                <span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span>
            <span class="k">else</span>
                <span class="n">next</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">.</span><span class="n">pNextOp</span>

        <span class="k">case</span> <span class="n">COND_STOP_ON_TRUE</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span>
                <span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span>
            <span class="k">else</span>
                <span class="n">next</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">.</span><span class="n">pNextOp</span>

        <span class="k">case</span> <span class="n">COND_SKIP_ON_FALSE</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>
                <span class="n">next</span> <span class="o">=</span> <span class="n">cmd</span>
                <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">cmd</span><span class="p">.</span><span class="n">condition</span><span class="p">.</span><span class="n">nSkip</span> <span class="k">do</span>
                    <span class="n">next</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">.</span><span class="n">pNextOp</span>

            <span class="k">else</span>
                <span class="n">next</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">.</span><span class="n">pNextOp</span>

        <span class="k">case</span> <span class="n">COND_SKIP_ON_TRUE</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span>
                <span class="n">next</span> <span class="o">=</span> <span class="n">cmd</span>
                <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">cmd</span><span class="p">.</span><span class="n">condition</span><span class="p">.</span><span class="n">nSkip</span> <span class="k">do</span>
                    <span class="n">next</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">.</span><span class="n">pNextOp</span>

            <span class="k">else</span>
                <span class="n">next</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">.</span><span class="n">pNextOp</span>

    <span class="k">return</span> <span class="n">next</span>
</pre></div>
</div>
</div>
<p>For every finished command, a RF core interrupt is raised which results in a
<span>RF_EventCmdDone</span> callback event from the RF driver. In addition,
the <span>RF_EventLastCmdDone</span> event is only generated:</p>
<ul class="simple">
<li>for single commands</li>
<li>for the the last command in a chain</li>
<li>when the execution result is <code class="docutils literal notranslate"><span class="pre">ABORT</span></code>.</li>
</ul>
<p>This is illustrated in the below sequence chart
<a class="reference internal" href="#fig-command-chain-callbacks"><span class="std std-numref">Figure 39.</span></a> for two chained operations <code class="docutils literal notranslate"><span class="pre">op1</span></code> and
<code class="docutils literal notranslate"><span class="pre">op2</span></code>. Only the first operation <code class="docutils literal notranslate"><span class="pre">op1</span></code> is delivered to the RF driver using
either <span>RF_postCmd</span> or <span>RF_runCmd</span>.  The RF core
then executes these operations and generates a callback event
<span>RF_EventCmdDone</span> for both and
<span>RF_EventLastCmdDone</span> only for the last operation <code class="docutils literal notranslate"><span class="pre">op2</span></code>.</p>
<div class="figure align-center" id="id8">
<span id="fig-command-chain-callbacks"></span><p class="plantuml">
<img src="../_images/plantuml-584789b016effcc6904cffe133c843e96dc2d91f.png" alt="&#64;startuml
scale 0.8
hide footbox

participant Application as app
participant &quot;RF Driver&quot; as driver
participant &quot;RF Core&quot; as rf

activate app
app -&gt; driver : RF_runCmd(op1);
activate driver
driver -&gt; rf : start op1
activate rf
driver &lt;-- rf

...op1 executes...

driver &lt;- rf : IRQ_CMD_DONE
activate driver
driver --&gt; rf
deactivate driver
app &lt;- driver : callback(RF_EventCmdDone);
activate app
app --&gt; driver
deactivate app

...op2 executes...

driver &lt;- rf : IRQ_CMD_DONE\n| IRQ_LAST_CMD_DONE
activate driver
driver --&gt; rf
deactivate rf
deactivate driver
app &lt;- driver : callback(RF_EventCmdDone\n| RF_EventLastCmdDone);
activate app
app --&gt; driver
deactivate app

app &lt;-- driver
deactivate driver

&#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 39. </span><span class="caption-text">The callback events <span>RF_EventCmdDone</span> and
<span>RF_EventLastCmdDone</span> for two chained RF
operations <code class="docutils literal notranslate"><span class="pre">op1</span></code> and <code class="docutils literal notranslate"><span class="pre">op2</span></code>.</span><a class="headerlink" href="#id8" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="callback-events">
<h1>Callback events<a class="headerlink" href="#callback-events" title="Permalink to this headline">¶</a></h1>
<p>The RF core generates multiple interrupts during command execution. The RF
driver maps these interrupts to callback events that execute in softare
interrupt context. Callback events are divided into 3 groups:</p>
<ul class="simple">
<li>Generic events, defined for all radio operation commands and originating on the RF core.
These are <span>RF_EventCmdDone</span> and <span>RF_EventLastCmdDone</span> as shown in
<a class="reference internal" href="#fig-rf-callback-events"><span class="std std-numref">Figure 40.</span></a>. Both events indicate the termination
of a radio operation command and are always generated at the same time.</li>
<li>Generic events, defined for all radio operation commands and originating in the RF driver.
These are explained in the RF driver API documentation.</li>
<li>Command-specific events, explained in the <a class="reference internal" href="rf-commands-reference.html"><span class="doc">RF commands reference</span></a> for
each command. These events occur during the <code class="docutils literal notranslate"><span class="pre">ACTIVE</span></code> phase. An example for
CMD_PROP_RX is given below in <a class="reference internal" href="#fig-rf-callback-events"><span class="std std-numref">Figure 40.</span></a>.</li>
</ul>
<div class="figure align-center" id="id9">
<span id="fig-rf-callback-events"></span><p class="plantuml">
<img src="../_images/plantuml-924c83b6ad2f7bce4961791c7786e6781d89e33a.png" alt="&#64;startuml
scale 0.8
hide footbox

participant Application as app
participant &quot;RF Driver&quot; as driver
participant &quot;RF Core&quot; as rf

activate app
app -&gt; driver : RF_runCmd(CMD_PROP_RX);
activate driver
driver -&gt; rf : start op
activate rf
driver &lt;-- rf

...CMD_PROP_RX executes...

driver &lt;- rf : IRQ_RX_ENTRY_DONE
activate driver
driver --&gt; rf
deactivate driver
driver -&gt; driver : post Swi
activate driver
app &lt;- driver : callback(RF_EventRxEntryDone);
activate app
note left
    Callback executes
    in Swi context
end note
app --&gt; driver
deactivate app
deactivate driver

...CMD_PROP_RX proceeds...

driver &lt;- rf : IRQ_CMD_DONE\n| IRQ_LAST_CMD_DONE
activate driver
driver --&gt; rf
deactivate rf
deactivate driver
driver -&gt; driver : post Swi
activate driver
app &lt;- driver : callback(RF_EventCmdDone\n| RF_EventLastCmdDone);
activate app
note left
    Callback executes
    in Swi context
end note
app --&gt; driver
deactivate app
deactivate driver

app &lt;-- driver
deactivate driver

&#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 40. </span><span class="caption-text">Example callback events for CMD_PROP_RX when 3 events are subscribed:
<span>RF_EventRxEntryDone</span>, <span>RF_EventCmdDone</span> and
<span>RF_EventLastCmdDone</span>.</span><a class="headerlink" href="#id9" title="Permalink to this image">¶</a></p>
</div>
<p>Note that all callback events execute in software interrupt context. Whether
they are really executed or not, depends on the <code class="docutils literal notranslate"><span class="pre">bmEvent</span></code> parameter in
<span>RF_postCmd</span> or <span>RF_runCmd</span>. The following
code snippet gives an example for CMD_PROP_RX:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Run a CMD_PROP_RX and register a callback for RF_EventCmdDone and RF_EventRxEntryDone</span>
<span class="n">RF_runCmd</span><span class="p">(</span><span class="n">rfHandle</span><span class="p">,</span> <span class="p">(</span><span class="n">RF_Op</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">RF_cmdPropRx</span><span class="p">,</span> <span class="n">RF_PriorityNormal</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxCallback</span><span class="p">,</span>
        <span class="n">RF_EventCmdDone</span> <span class="o">|</span> <span class="n">RF_EventRxEntryDone</span><span class="p">);</span>


<span class="c1">// RX callback handler</span>
<span class="c1">// Multiple events might occur at the same time.</span>
<span class="kt">void</span> <span class="nf">rxCallback</span><span class="p">(</span><span class="n">RF_Handle</span> <span class="n">h</span><span class="p">,</span> <span class="n">RF_CmdHandle</span> <span class="n">ch</span><span class="p">,</span> <span class="n">RF_EventMask</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">&amp;</span> <span class="n">RF_EventRxEntryDone</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Do something, for instance post a semaphore.</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">&amp;</span> <span class="n">RF_EventCmdDone</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Do something</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="phy-configuration.html" class="btn btn-neutral float-right" title="PHY Configuration" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="commands.html" class="btn btn-neutral float-left" title="Command Types" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">2016-2020, Texas Instruments</a>, Texas Instruments Incorporated. All rights reserved. <br>
        <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>