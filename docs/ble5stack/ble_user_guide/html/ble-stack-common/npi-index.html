

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Network Processor Interface (NPI) &mdash; 
SimpleLink™ CC2640R2 SDK
BLE5-Stack User&#39;s Guide
 1.01.11.00 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Sensor Controller" href="../sensor-controller/sensor-controller.html" />
    <link rel="prev" title="Voice over BLE" href="../voice/ble_voice.html" />
    <script language="JavaScript">
        var tiPageName;
        tiPageName = "sug ble-stack-common npi-index";

        if (location.protocol == "file:"){
            var ci_analytics_poc_load = true;
        }
    </script>

    <script src="http://www.ti.com/assets/js/headerfooter/analytics.js" type="text/javascript" charset="utf-8"></script>


</head>

<body class="wy-body-for-nav">
   <!---- extra body elements for TI beyond RTD Sphinx Theme --->
<div class="DocSite-globalNav tiNav">
    <ul>
    </ul>
</div>

<a class="DocSite-nav" href="https://www.ti.com" style="padding-bottom: 85px;">
  <img class="DocSiteNav-logo"
    src="../_static/img/ti_logo.png"
    alt="TI Logo">
  <div class="DocSiteNav-title"></div>
</a> 
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../ble-stack-5.x-guide/index-cc2640.html" class="icon icon-home" alt="Documentation Home"> 
SimpleLink™ CC2640R2 SDK
BLE5-Stack User's Guide

          

          
          </a>

          
            
            
              <div class="version">
                1.01.11.00
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../ble-stack-5.x-guide/disclaimer.html">Disclaimer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quickstart-guide/ble5-quick-start-cc2640.html">TI BLE5-Stack Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ble-stack-5.x-guide/software_architecture.html">Software Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ble-stack-5.x-guide/tirtos-index.html">TI-RTOS (RTOS Kernel) Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ble-stack-5.x-guide/ble-stack-5-index-cc2640.html">Application</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ble-stack-5.x-guide/ble-stack-5-index-cc2640.html#ble5-stack">BLE5-Stack</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ble-stack-5.x-guide/ble-stack-5-index-cc2640.html#developing-a-custom-application">Developing a Custom Application</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ble-stack-5.x-guide/ble-stack-5-index-cc2640.html#running-the-sdk-on-custom-hardware">Running the SDK on Custom Hardware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../voice/voice.html">Creating a Voice Enabled Application</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Network Processor Interface (NPI)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#legacy-npi">Legacy NPI</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#signaling-protocol">Signaling Protocol</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#npi-signaling">NPI Signaling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#npi-handshake">NPI Handshake</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#packet-format">Packet Format</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#spi">SPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="#uart">UART</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#message-types">Message Types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#asynchronous">Asynchronous</a></li>
<li class="toctree-l4"><a class="reference internal" href="#synchronous">Synchronous</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#unified-npi">Unified NPI</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#unpi-architecture">UNPI Architecture</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unpi-signaling">UNPI Signaling</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#unpi-handshake">UNPI Handshake</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id2">Packet Format</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">Message Types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#synchronous-messages">Synchronous Messages</a></li>
<li class="toctree-l4"><a class="reference internal" href="#asynchronous-messages">Asynchronous Messages</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#bidirectional-messaging">Bidirectional Messaging</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unpi-usage">UNPI Usage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id4">UART</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">SPI</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#implementing-an-npi-master">Implementing An NPI Master</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../sensor-controller/sensor-controller.html">Sensor Controller</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ble-stack-5.x-guide/debugging-index.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ble-stack-5.x-guide/migration-cc2640.html">Updating from previous SDKs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ble-stack-5.x-guide/api-reference-cc2640.html">API References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ble-stack-5.x-guide/reference-cc2640.html">Terms and Definitions</a></li>
</ul>

            
          
          <!-- extra nav elements for TI beyond RTD Sphinx Theme --->
<div id="sideBanner">
    <br/>
    <br/><br/><br/>
</div>
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../ble-stack-5.x-guide/index-cc2640.html">
SimpleLink™ CC2640R2 SDK
BLE5-Stack User's Guide
</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../ble-stack-5.x-guide/index-cc2640.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Network Processor Interface (NPI)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="network-processor-interface-npi">
<span id="sec-npi"></span><h1>Network Processor Interface (NPI)<a class="headerlink" href="#network-processor-interface-npi" title="Permalink to this headline">¶</a></h1>
<p>TI’s Network Processor Interface (<a class="reference internal" href="../ble-stack-5.x-guide/reference-cc2640.html#term-npi"><span class="xref std std-term">NPI</span></a>) is used for establishing a serial
data link between a TI SoC and external MCUs or PCs. It is an abstraction layer
above the serial interface (UART or SPI) that handles sending / receiving
data power management, and data parsing  It is mainly used by TI’s
network processor solutions. There are two types of NPI used by BLE and they
are described in the following sections.</p>
<div class="section" id="legacy-npi">
<span id="npi-legacy"></span><h2>Legacy NPI<a class="headerlink" href="#legacy-npi" title="Permalink to this headline">¶</a></h2>
<p>Anything that is not specifically “Unified NPI” is Legacy NPI. For example,
the hostTest project uses Legacy NPI. For the remainder of this section, NPI
will always refer to Legacy NPI</p>
<p>TI provides the source code for NPI and it can be found in the following files
at $SDK_INSTALL$sourcetiblestacknpisrc:</p>
<ul class="simple">
<li>npi_client_mt.c</li>
<li>npi_frame_hci.c</li>
<li>npi_fram_mt.c</li>
<li>npi_rxbuf.c</li>
<li>npi_task.c</li>
<li>npi_tl.c</li>
<li>npi_tl_spi.c or npi_tl_uart.c</li>
</ul>
<div class="section" id="signaling-protocol">
<h3>Signaling Protocol<a class="headerlink" href="#signaling-protocol" title="Permalink to this headline">¶</a></h3>
<p>Each processor in an NPI solution must occupy either the master or slave role.
The TI wireless SoC generally occupies the slave role in the network processor
examples included in the SDK.</p>
<div class="section" id="npi-signaling">
<h4>NPI Signaling<a class="headerlink" href="#npi-signaling" title="Permalink to this headline">¶</a></h4>
<p>In order to properly manage the power domains of the device, there must be a way
for an external host to wake the network processor from low power modes. This is
done through the inclusion of the following pins:</p>
<ul class="simple">
<li>Master Ready (<a class="reference internal" href="../ble-stack-5.x-guide/reference-cc2640.html#term-mrdy"><span class="xref std std-term">MRDY</span></a>): A GPIO pin whose logic level indicates the state of
the master processor. MRDY is an active low (low true) signal. An MRDY event
indicates that the master processor is ready to send or receive data.</li>
<li>Slave Ready (<a class="reference internal" href="../ble-stack-5.x-guide/reference-cc2640.html#term-srdy"><span class="xref std std-term">SRDY</span></a>):  A GPIO pin whose logic level indicates the state of
the slave processor. SRDY is an active low (low true) signal. An SRDY event
indicates that the slave processor is ready to send or receive data.</li>
</ul>
<p>In the slave role, MRDY is an input pin and SRDY is an output in. In the master
role, MRDY is an output pin and SRDY is an input pin.</p>
</div>
<div class="section" id="npi-handshake">
<h4>NPI Handshake<a class="headerlink" href="#npi-handshake" title="Permalink to this headline">¶</a></h4>
<p>In order to start an
NPI transaction, there first must occur a handshake sequence using the MRDY and
SRDY pins. This handshake is required in order to guarantee that both devices are
awake and ready to send and/or receive data. Whichever device first starts the
handshake sequence is termed the “initiator”. Either the slave or the master may
may be the imitator. The NPI transaction is completed by the master
raising MRDY followed by the slave raising SRDY.</p>
<p>The figures below illustrate both master and slave-initiated NPI transactions</p>
<blockquote>
<div><div class="figure align-center" id="id6">
<img alt="../_images/legacy_npi_timing_master_initiates.png" src="../_images/legacy_npi_timing_master_initiates.png" />
<p class="caption"><span class="caption-number">Figure 94. </span><span class="caption-text">Timing for Master-Initiated NPI Transaction</span></p>
</div>
<div class="figure align-center" id="id7">
<img alt="../_images/legacy_npi_timing_slave_initiates.png" src="../_images/legacy_npi_timing_slave_initiates.png" />
<p class="caption"><span class="caption-number">Figure 95. </span><span class="caption-text">Timing for Slave-Initiated NPI Transaction</span></p>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="packet-format">
<h3>Packet Format<a class="headerlink" href="#packet-format" title="Permalink to this headline">¶</a></h3>
<p>The NPI module handles the serial driver-level packet formatting, stripping of
the NPI, header and FCS when unpacking. This section will describe the packet
format to be used with NPI.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This section does not consider the packet format of the data payload section
of the NPI packet format as this is dependent on the NPI use case (i.e. HCI
packet format for BLE).</p>
</div>
<p>The packet format is dependent on the serial protocol being used and described
in the following sections.</p>
<div class="section" id="spi">
<h4>SPI<a class="headerlink" href="#spi" title="Permalink to this headline">¶</a></h4>
<p>In order to understand the structure of the TL packet format, it is necessary to
understand the complications inherent in the SPI protocol. The first limitation is
that the SPI master must trigger the clock signal (SCLK) in order to receive
bytes from the slave. If the slave is sending a message, then the master must
know how long this message is in order to receive the complete message. The
other limitation of SPI is that if the clock signal is triggered, the master
or slave must transmit empty bytes if they have nothing to send. The simple
scenario when this occurs is during either a communication sequence where either
the master or slave receives only empty bytes. These messages of strictly empty
bytes could be easily ignored but the bidirectional message scenario requires
more complex handling. If the slave and master are both transmitting non-empty
bytes then the shorter message will have to be padded with empty bytes so that
the longer message can be fully transmitted. Determining which bytes of message
bytes versus empty bytes in this scenario requires message delimitation. In
order to handle these limitations of SPI, the NPI SPI Frame is used for all
NPI messages sent over SPI.</p>
<p>The NPI SPI Frame has four fields described thus and pictured below:</p>
<ul class="simple">
<li>1 byte Start of Frame (SOF): always 0xFE</li>
<li>1 byte length: length of the data payload field (must be between
0-255 bytes)</li>
<li>0-255 byte Data Payload</li>
<li>1 byte Frame Check Sequence (FCS): calculated by doing a XOR on
each byte of the frame in the order they are sent/received on the bus. The SOF
byte shall not be included in the FCS calculation.</li>
</ul>
<blockquote>
<div><div class="figure align-center" id="id8">
<img alt="../_images/legacy_npi_spi_protocol.png" src="../_images/legacy_npi_spi_protocol.png" />
<p class="caption"><span class="caption-number">Figure 96. </span><span class="caption-text">NPI SPI Packet Format</span></p>
</div>
</div></blockquote>
<p>This NPI SPI Frame handles both the delimitation of empty vs non empty data
bytes as well as having a fixed length field allowing the SPI master to know how
many times the SCLK signal must be toggled to receive a complete message from
the SPI slave.</p>
</div>
<div class="section" id="uart">
<h4>UART<a class="headerlink" href="#uart" title="Permalink to this headline">¶</a></h4>
<p>Since UART does not have the same inherent complication as SPI, a much simpler
frame format can be used. Because UART RX and TX channels are independent of each
other, there is no need for a predefined fixed length field, Furthermore, since
there are no empty bytes that must be transmitted, each frame does not need to
be delimited. Therefore, every byte received over UART RX or TX
channels can be treated as a valid byte of data payload. This allows the NPI
UART Frame to consist of only a data payload field:</p>
<blockquote>
<div><div class="figure align-center" id="id9">
<img alt="../_images/legacy_npi_uart_protocol.png" src="../_images/legacy_npi_uart_protocol.png" />
<p class="caption"><span class="caption-number">Figure 97. </span><span class="caption-text">NPI UART Packet Format</span></p>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="message-types">
<h3>Message Types<a class="headerlink" href="#message-types" title="Permalink to this headline">¶</a></h3>
<p>Both synchronous and asynchronous messages can be supported by NPI. By default,
only asynchronous messages are supported. Support for synchronous messages can
be compiled into NPI using the compiler define <code class="docutils literal notranslate"><span class="pre">NPI_SREQRSP</span></code>.</p>
<div class="section" id="asynchronous">
<h4>Asynchronous<a class="headerlink" href="#asynchronous" title="Permalink to this headline">¶</a></h4>
<p>There are two types of asynchronous messages: asynchronous request
((<a class="reference internal" href="../ble-stack-5.x-guide/reference-cc2640.html#term-areq"><span class="xref std std-term">AREQ</span></a>)) and asynchronous indication ((<a class="reference internal" href="../ble-stack-5.x-guide/reference-cc2640.html#term-aind"><span class="xref std std-term">AIND</span></a>)). These messages
have the same frame, but the difference lies in whether the transfer was
initiated by the network processor (AIND) or the host/application
processor (AREQ).</p>
</div>
<div class="section" id="synchronous">
<h4>Synchronous<a class="headerlink" href="#synchronous" title="Permalink to this headline">¶</a></h4>
<p>Synchronous messages are blocking in that once a synchronous request
((<a class="reference internal" href="../ble-stack-5.x-guide/reference-cc2640.html#term-sreq"><span class="xref std std-term">SREQ</span></a>)) is sent over NPI all other NPI transmissions are blocked until
a corresponding synchronous response ((<a class="reference internal" href="../ble-stack-5.x-guide/reference-cc2640.html#term-sresp"><span class="xref std std-term">SRESP</span></a>)) is returned.</p>
</div>
</div>
</div>
<div class="section" id="unified-npi">
<span id="npi-unified"></span><h2>Unified NPI<a class="headerlink" href="#unified-npi" title="Permalink to this headline">¶</a></h2>
<p>If Unified NPI is being referenced, it will be specifically referred to as
“Unified NPI” or (<a class="reference internal" href="../ble-stack-5.x-guide/reference-cc2640.html#term-111"><span class="xref std std-term">UNPI</span></a>). Anything that is not specifically called
“Unified NPI” is Legacy NPI. However, the API’s and source files of the UNPI
implementation will still always be called “NPI”.</p>
<p>Unified NPI offers some improvements over NPI in that it offers a unified frame
format that is used by all transport layers.</p>
<p>TI provides the source code for UNPI and it can be found in the following files
at <em>&lt;SDK_INSTALL_DIR&gt;\source\tiblstacknpi\src\unified</em></p>
<ul class="simple">
<li>npi_task.c</li>
<li>npi_tl.c</li>
<li>npi_tl_spi.c or npi_tl_uart.c</li>
<li>npi_util.c</li>
</ul>
<div class="section" id="unpi-architecture">
<h3>UNPI Architecture<a class="headerlink" href="#unpi-architecture" title="Permalink to this headline">¶</a></h3>
<p>UNPI is implemented as its own TI-RTOS task, and supports inter task
communication and routing to the underlying serial interface drivers. See the
diagram below for details:</p>
<blockquote>
<div><div class="figure align-center" id="id10">
<a class="reference internal image-reference" href="../_images/unified_npi_block_diagram.png"><img alt="../_images/unified_npi_block_diagram.png" src="../_images/unified_npi_block_diagram.png" style="width: 274.8px; height: 492.59999999999997px;" /></a>
<p class="caption"><span class="caption-number">Figure 98. </span><span class="caption-text">Block Diagram for UNPI</span></p>
</div>
</div></blockquote>
</div>
<div class="section" id="unpi-signaling">
<h3>UNPI Signaling<a class="headerlink" href="#unpi-signaling" title="Permalink to this headline">¶</a></h3>
<p>Each processor in an UNPI solution must occupy either the master or slave role.
The TI wireless SoC generally occupies the slave role in the network processor
examples included in the SDK.</p>
<p>For the remainder of this section, the following terms will be used:</p>
<ul class="simple">
<li>Application Processor ((<a class="reference internal" href="../ble-stack-5.x-guide/reference-cc2640.html#term-116"><span class="xref std std-term">AP</span></a>): UNPI Master (the host MCU)</li>
<li>Network Processor ((<a class="reference internal" href="../ble-stack-5.x-guide/reference-cc2640.html#term-114"><span class="xref std std-term">NP</span></a>)): UNPI Slave (the TI network processor)</li>
</ul>
<p>In order to properly manage the power domains of the device, there must be a way
for an external host to wake the network processor from low power modes. This is
done through the inclusion of the following pins:</p>
<ul class="simple">
<li>Master Ready (<a class="reference internal" href="../ble-stack-5.x-guide/reference-cc2640.html#term-mrdy"><span class="xref std std-term">MRDY</span></a>): A GPIO pin whose logic level indicates the state of
the master processor. MRDY is an active low (low true) signal. An MRDY event
indicates that the master processor is ready to send or receive data.</li>
<li>Slave Ready (<a class="reference internal" href="../ble-stack-5.x-guide/reference-cc2640.html#term-srdy"><span class="xref std std-term">SRDY</span></a>):  A GPIO pin whose logic level indicates the state of
the slave processor. SRDY is an active low (low true) signal. An SRDY event
indicates that the slave processor is ready to send or receive data.</li>
</ul>
<p>In the slave role, MRDY is an input pin and SRDY is an output in. In the master
role, MRDY is an output pin and SRDY is an input pin.</p>
<div class="section" id="unpi-handshake">
<h4>UNPI Handshake<a class="headerlink" href="#unpi-handshake" title="Permalink to this headline">¶</a></h4>
<p>In order to start an
UNPI transaction, there first must occur a handshake sequence using the MRDY and
SRDY pins. This handshake is required in order to guarantee that both devices are
awake and ready to send and/or receive data. Whichever device first starts the
handshake sequence is termed the “initiator”. Either the slave or the master may
may be the imitator. The UNPI transaction is completed by the master
raising MRDY followed by the slave raising SRDY.</p>
<p>The figures below illustrate both master and slave-initiated UNPI transactions</p>
<blockquote>
<div><div class="figure align-center" id="id11">
<img alt="../_images/unified_npi_timing_master_initiates.png" src="../_images/unified_npi_timing_master_initiates.png" />
<p class="caption"><span class="caption-number">Figure 99. </span><span class="caption-text">Timing for Master-Initiated UNPI Transaction</span></p>
</div>
<div class="figure align-center" id="id12">
<img alt="../_images/unified_npi_timing_slave_initiates.png" src="../_images/unified_npi_timing_slave_initiates.png" />
<p class="caption"><span class="caption-number">Figure 100. </span><span class="caption-text">Timing for Slave-Initiated UNPI Transaction</span></p>
</div>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Bidirectional (full-duplex) messaging is also possible with UNPI. See the
section below for more details.</p>
</div>
</div>
</div>
<div class="section" id="id2">
<h3>Packet Format<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>The Unified NPI packet format consists of the following fields and is pictured
below:</p>
<ul class="simple">
<li>1 byte Start of Frame (<a class="reference internal" href="../ble-stack-5.x-guide/reference-cc2640.html#term-sof"><span class="xref std std-term">SOF</span></a>): always 0xFE</li>
<li>2 byte Length field in little-endian format (so LSB first)</li>
<li>1 byte Type / Subsystem: that contains both message type and subsystem
information as such:<ul>
<li>Bits[7:5]: Message type, see the message type section for more info</li>
<li>Bits[4:0]: Subsystem ID field, used to help UNPI route the message to the
appropriate place.</li>
</ul>
</li>
<li>1 byte command ID: opcode of the command being sent</li>
<li>variable length Payload: the length of the payload is defined by the length
field.</li>
<li>1 byte Frame Check Sequence (<a class="reference internal" href="../ble-stack-5.x-guide/reference-cc2640.html#term-fcs"><span class="xref std std-term">FCS</span></a>): calculated by doing a XOR on each
byte of the frame in the order they are sent / received on the bus. The SOF
byte is always excluded from the FCS calculation.</li>
</ul>
<blockquote>
<div><div class="figure align-center" id="id13">
<img alt="../_images/unified_npi_packet_format.png" src="../_images/unified_npi_packet_format.png" />
<p class="caption"><span class="caption-number">Figure 101. </span><span class="caption-text">UNPI Packet Format</span></p>
</div>
</div></blockquote>
</div>
<div class="section" id="id3">
<h3>Message Types<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>There are three message types supported by Unified NPI. The type of message
being sent is often dependent on which processor initiated the transaction. The
message types are described below.</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Code</th>
<th class="head">Message Type</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x01</td>
<td>Synchronous Request (SREQ)</td>
</tr>
<tr class="row-odd"><td>0x02</td>
<td>Asynchronous Request/Indication (AREQ/AIND)</td>
</tr>
<tr class="row-even"><td>0x03</td>
<td>Synchronous Response (SRESP)</td>
</tr>
</tbody>
</table>
<div class="section" id="synchronous-messages">
<h4>Synchronous Messages<a class="headerlink" href="#synchronous-messages" title="Permalink to this headline">¶</a></h4>
<p>A Synchronous Request ((<a class="reference internal" href="../ble-stack-5.x-guide/reference-cc2640.html#term-sreq"><span class="xref std std-term">SREQ</span></a>)) is a frame, defined by data content
instead of the ordering of events of the physical interface, which is sent from
the Host to NP where the next frame sent from NP to Host must be the Synchronous
Response ((<a class="reference internal" href="../ble-stack-5.x-guide/reference-cc2640.html#term-sresp"><span class="xref std std-term">SRESP</span></a>)) to that SREQ. Once a SREQ is sent, the UNPI interface
blocks until a corresponding response (SRESP) is received.</p>
</div>
<div class="section" id="asynchronous-messages">
<h4>Asynchronous Messages<a class="headerlink" href="#asynchronous-messages" title="Permalink to this headline">¶</a></h4>
<p>There are two types of asynchronous messages: asynchronous request
((<a class="reference internal" href="../ble-stack-5.x-guide/reference-cc2640.html#term-areq"><span class="xref std std-term">AREQ</span></a>)) and asynchronous indication ((<a class="reference internal" href="../ble-stack-5.x-guide/reference-cc2640.html#term-aind"><span class="xref std std-term">AIND</span></a>)). These messages
have the same frame, but the difference lies in whether the transfer was
initiated by the network processor (AIND) or the host/application
processor (AREQ).</p>
</div>
</div>
<div class="section" id="bidirectional-messaging">
<h3>Bidirectional Messaging<a class="headerlink" href="#bidirectional-messaging" title="Permalink to this headline">¶</a></h3>
<p>There are inherently collisions between messages in any protocol that allows
asynchronous messaging (where a signal transition denotes the start of a message
as with MRDY and SRDY).  Instead of requiring intricate collision handling,
the UNPI framework allows for bidirectional messaging to occur. This means that
data can be sent from the AP to NP and from NP to the AP in the same message
window regardless of the handshake order.</p>
<p>While reducing collision handling, bidirectional messaging adds some complexity
to what operations must be performed or initiated by each device. For every AIND
the NP initiates, it must prepare to both read and write when MRDY is
asserted. For every REQ, the AP must prepare to both read and write once SRDY
is asserted. Each device will also need to handle any FIFOs that could
potentially be overrun during a message and check at the end of every message
to see what, if anything, has been received.</p>
<p>The flow chart for bidirectional message is shown here:</p>
<blockquote>
<div><div class="figure align-center" id="id14">
<img alt="../_images/unified_npi_bidirection.png" src="../_images/unified_npi_bidirection.png" />
<p class="caption"><span class="caption-number">Figure 102. </span><span class="caption-text">UNPI Bidirectional Flow Chart</span></p>
</div>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Bidirectional messaging is enabled regardless of power savings options</p>
</div>
</div>
<div class="section" id="unpi-usage">
<h3>UNPI Usage<a class="headerlink" href="#unpi-usage" title="Permalink to this headline">¶</a></h3>
<p>Currently, the UNPI protocol has been implemented using the UART and SPI drivers
on CC26xx devices. There are certain driver specific settings that should be
configured which are defined in the following sections.</p>
<p>Initially, the UNPI task doesn’t initiate the MRDY and SRDY pins; it will let
the pins default to <code class="docutils literal notranslate"><span class="pre">IOID_UNUSED</span></code>. It is application’s responsibility to define
these pins as such:</p>
<blockquote>
<div><div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#define MDRY_PIN        Board_PIN_BUTTON0</span>
<span class="cp">#define SDRY_PIN        Board_PIN_BUTTON1</span>
<span class="p">...</span>
<span class="c1">// NP Parameters for opening serial port to NP</span>
<span class="k">static</span> <span class="n">NPI_Params</span> <span class="n">portParams</span><span class="p">;</span>
<span class="p">...</span>
<span class="cp">#ifdef NPI_USE_UART</span>
  <span class="n">NPITask_Params_init</span><span class="p">(</span><span class="n">NPI_SERIAL_TYPE_UART</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portParams</span><span class="p">);</span>
<span class="cp">#elif defined(NPI_USE_SPI)</span>
  <span class="n">NPITask_Params_init</span><span class="p">(</span><span class="n">NPI_SERIAL_TYPE_SPI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portParams</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#error &quot;Must define NPI_USE_UART or NPI_USE_SPI for any project including NPI&quot;</span>
<span class="cp">#endif </span><span class="c1">//NPI_USE_UART</span>
  <span class="n">portParams</span><span class="p">.</span><span class="n">stackSize</span> <span class="o">=</span> <span class="n">NPI_TASK_STACK_SIZE</span><span class="p">;</span>
  <span class="n">portParams</span><span class="p">.</span><span class="n">mrdyPinID</span> <span class="o">=</span> <span class="n">MDRY_PIN</span><span class="p">;</span>
  <span class="n">portParams</span><span class="p">.</span><span class="n">srdyPinID</span> <span class="o">=</span> <span class="n">SDRY_PIN</span><span class="p">;</span>
  <span class="n">portParams</span><span class="p">.</span><span class="n">bufSize</span>   <span class="o">=</span> <span class="mi">530</span><span class="p">;</span>

  <span class="c1">// Kick off NPI</span>
  <span class="n">NPITask_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">portParams</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<div class="section" id="id4">
<h4>UART<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>To use this configuration, the UART project configuration should be selected
(if available). This configuration allows low power modes through the inclusion
of the MRDY and SRDY signals. If a pre-made project configuration is not
included in the SDK, then <code class="docutils literal notranslate"><span class="pre">NPI_USE_UART</span></code> must be defined as well as including
the CC26xx UART drivers. If power management is needed, be sure to define
<code class="docutils literal notranslate"><span class="pre">POWER_SAVING</span></code> and use the MRDY/SRDY signals. The NPI task sets up the UART port
with the following settings:</p>
<table border="1" class="docutils">
<colgroup>
<col width="48%" />
<col width="52%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Default Value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Baud Rate</td>
<td>115200</td>
</tr>
<tr class="row-odd"><td>Data Length</td>
<td>8</td>
</tr>
<tr class="row-even"><td>Parity</td>
<td>None</td>
</tr>
<tr class="row-odd"><td>Stop Bits</td>
<td>1</td>
</tr>
<tr class="row-even"><td>Flow Control</td>
<td>None</td>
</tr>
</tbody>
</table>
<p>Changing the baud rate can be done in the <code class="docutils literal notranslate"><span class="pre">NPITask_Params_init()</span></code> function as
below:</p>
<blockquote>
<div><div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">UART_Params_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">portParams</span><span class="p">.</span><span class="n">uartParams</span><span class="p">);</span>
<span class="n">params</span><span class="o">-&gt;</span><span class="n">portParams</span><span class="p">.</span><span class="n">uartParams</span><span class="p">.</span><span class="n">readDataMode</span> <span class="o">=</span> <span class="n">UART_DATA_BINARY</span><span class="p">;</span>
<span class="n">params</span><span class="o">-&gt;</span><span class="n">portParams</span><span class="p">.</span><span class="n">uartParams</span><span class="p">.</span><span class="n">writeDataMode</span> <span class="o">=</span> <span class="n">UART_DATA_BINARY</span><span class="p">;</span>
<span class="n">params</span><span class="o">-&gt;</span><span class="n">portParams</span><span class="p">.</span><span class="n">uartParams</span><span class="p">.</span><span class="n">readMode</span> <span class="o">=</span> <span class="n">UART_MODE_CALLBACK</span><span class="p">;</span>
<span class="n">params</span><span class="o">-&gt;</span><span class="n">portParams</span><span class="p">.</span><span class="n">uartParams</span><span class="p">.</span><span class="n">writeMode</span> <span class="o">=</span> <span class="n">UART_MODE_CALLBACK</span><span class="p">;</span>
<span class="n">params</span><span class="o">-&gt;</span><span class="n">portParams</span><span class="p">.</span><span class="n">uartParams</span><span class="p">.</span><span class="n">readEcho</span> <span class="o">=</span> <span class="n">UART_ECHO_OFF</span><span class="p">;</span>
<span class="n">params</span><span class="o">-&gt;</span><span class="n">portParams</span><span class="p">.</span><span class="n">uartParams</span><span class="p">.</span><span class="n">baudRate</span><span class="o">=</span> <span class="mi">460800</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
</div>
<div class="section" id="id5">
<h4>SPI<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>In order to allow full duplex communication, the SPI configuration requires the
use of MRDY and SRDY regardless of whether or not power management is enabled.
In order to use SPI, use the project configuration included in the SDK (if
applicable). If a project configuration is unavailable, then <code class="docutils literal notranslate"><span class="pre">NPI_USE_SPI</span></code>
should be defined as well as including the CC26xx SPI drivers. If power savings
is needed, be sure to define <code class="docutils literal notranslate"><span class="pre">POWER_SAVINGS</span></code>.</p>
<p>The NPI task will initialize the SPI with the following parameters</p>
<table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Default Value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Bit Rate</td>
<td>800000</td>
</tr>
<tr class="row-odd"><td>Data Length</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>Changing the bit rate can be done in the <code class="docutils literal notranslate"><span class="pre">NPITask_Params_init()</span></code> function as
below:</p>
<blockquote>
<div><div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">SPI_Params_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">params</span><span class="o">-&gt;</span><span class="n">portParams</span><span class="p">.</span><span class="n">spiParams</span><span class="p">);</span>
<span class="n">params</span><span class="o">-&gt;</span><span class="n">portParams</span><span class="p">.</span><span class="n">spiParams</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">SPI_SLAVE</span><span class="p">;</span>
<span class="n">params</span><span class="o">-&gt;</span><span class="n">portParams</span><span class="p">.</span><span class="n">spiParams</span><span class="p">.</span><span class="n">bitRate</span> <span class="o">=</span> <span class="mi">8000000</span><span class="p">;</span>
<span class="n">params</span><span class="o">-&gt;</span><span class="n">portParams</span><span class="p">.</span><span class="n">spiParams</span><span class="p">.</span><span class="n">frameFormat</span> <span class="o">=</span> <span class="n">SPI_POL1_PHA1</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
</div>
</div>
<div class="section" id="implementing-an-npi-master">
<h3>Implementing An NPI Master<a class="headerlink" href="#implementing-an-npi-master" title="Permalink to this headline">¶</a></h3>
<p>As stated above, the TI device operates as an NPI slave in the network processor
use case. This means the external MCU must implement the master UNPI role. When
developing the NPI master role on an external MCU, there are a couple things to
keep in mind:</p>
<ul class="simple">
<li>The NPI master controls MRDY and thus controls when the NPI frame has
completed.</li>
<li>Even when the slave is sending data, the master must use the
payload format to determine how many bytes it expects and raise MRDY when it
has received them.</li>
<li>Since all packets use the same frame format regardless of protocol,
the NPI master can use the frame format to determine when to raise MRDY.</li>
</ul>
<p>An example of an NPI master implementation for UART can be found at
<em>&lt;SDK_INSTALL_DIR&gt;\source\tiblstacknpi\src\unified\npi_tl_uart_m.c</em></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">NPI_MASTER</span></code> must be defined as a preprocessor symbol to use the above file.</p>
</div>
<p>When toggling MRDY / SRDY it is important to remember the following rules:</p>
<ul class="simple">
<li>Each device must always initiate a read prior to asserting its respective
output pin (MRDY with respect to the AP) regardless of the state of the its
respective input pin (SRDY with respect to the AP).</li>
<li>Each device can only begin to write (or clock data in the case of SPI) once
both MRDY and SRDY are asserted.</li>
</ul>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../sensor-controller/sensor-controller.html" class="btn btn-neutral float-right" title="Sensor Controller" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../voice/ble_voice.html" class="btn btn-neutral float-left" title="Voice over BLE" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">2010-2020, Texas Instruments</a>, Texas Instruments Incorporated. All rights reserved. <br>
        <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
  
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>